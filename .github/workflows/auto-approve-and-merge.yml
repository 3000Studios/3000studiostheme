name: Auto Approve and Merge (always)

on:
  pull_request_target:
    types: [opened, reopened, labeled, synchronize, ready_for_review]
  schedule:
    - cron: '*/15 * * * *'   # run every 15 minutes
  workflow_dispatch: {}

permissions:
  contents: write  # Required for merging PRs
  pull-requests: write
  issues: write
  checks: read


jobs:
  auto-approve-and-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve and merge (handler)
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.MERGE_PAT }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const actorToNotify = '@3000Studios';

            async function processPR(pr) {
              const number = pr.number;
              console.log(`Processing PR #${number} - ${pr.title} by ${pr.user.login}`);
              
              // Skip if PR is already merged or closed
              if (pr.state !== 'open') {
                console.log(`Skipping PR #${number} - already ${pr.state}`);
                return;
              }
              
              // Check for auto-merge label (opt-in mechanism)
              const hasAutoMergeLabel = pr.labels && pr.labels.some(label => 
                label.name === 'auto-merge' || label.name === 'automerge'
              );
              if (!hasAutoMergeLabel) {
                console.log(`Skipping PR #${number} - missing 'auto-merge' label`);
                return;
              }
              
              // Verify all required checks have passed
              try {
                const checks = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: pr.head.sha
                });
                
                // If there are check runs, all must pass
                if (checks.data.check_runs.length > 0) {
                  const allChecksPassed = checks.data.check_runs.every(run => 
                    run.status === 'completed' && run.conclusion === 'success'
                  );
                  
                  if (!allChecksPassed) {
                    console.log(`Skipping PR #${number} - checks not passed`);
                    return;
                  }
                }
                
                // Also check commit statuses (for legacy CI systems)
                const statuses = await github.rest.repos.getCombinedStatusForRef({
                  owner,
                  repo,
                  ref: pr.head.sha
                });
                
                // If there are statuses, the combined state must be success
                if (statuses.data.statuses.length > 0 && statuses.data.state !== 'success') {
                  console.log(`Skipping PR #${number} - status checks: ${statuses.data.state}`);
                  return;
                }
              } catch (err) {
                console.log(`Check verification failed for PR #${number}: ${err.message || err}`);
                return;
              }
              
              try {
                await github.rest.pulls.createReview({
                  owner,
                  repo,
                  pull_number: number,
                  event: 'APPROVE'
                });
                console.log(`Approved PR #${number}`);
              } catch (err) {
                console.log(`Approve failed for PR #${number}: ${err.message || err}`);
              }

              try {
                const mergeResp = await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: number,
                  merge_method: 'squash'
                });
                const sha = mergeResp.data && mergeResp.data.sha ? mergeResp.data.sha : '';
                console.log(`Merged PR #${number} - sha: ${sha}`);

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: number,
                  body: `${actorToNotify} â€” This PR was auto-approved and auto-merged by repository automation. Merge SHA: ${sha}`
                });

                await github.rest.issues.create({
                  owner,
                  repo,
                  title: `Auto-merge report: PR #${number} - ${pr.title}`,
                  body: `Automated approval and merge executed.\n\n- PR: #${number}\n- Title: ${pr.title}\n- Author: ${pr.user.login}\n- Merge SHA: ${sha}\n- Merged by workflow: ${context.workflow}\n`
                });

                console.log(`Notified and logged PR #${number}`);
              } catch (err) {
                console.log(`Merge/notify failed for PR #${number}: ${err.message || err}`);
              }
            }

            const payloadPR = context.payload && context.payload.pull_request;
            if (payloadPR) {
              await processPR(payloadPR);
            } else {
              const listParams = { owner, repo, state: 'open', per_page: 100 };
              const response = await github.rest.pulls.list(listParams);
              const prs = response.data || [];
              console.log(`Found ${prs.length} open PR(s) to process.`);
              for (const pr of prs) {
                await processPR(pr);
              }
            }